<html>
 <head>
  <title>BinaryCodes Problem Statement</title>
 </head>
 <body>
  <table>
   <tbody>
    <tr>
     <td colspan="2"><h3><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=8247">Problem Statement for BinaryCodes</a></h3></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td><p> Given a finite alphabet <tt>S</tt>, a binary code over this alphabet <tt>S</tt> is a function that maps each element of <tt>S</tt> to some (possibly empty) string over the alphabet <tt>{0,1}</tt>. </p> <p> An example of such a code for <tt>S={a,b,c,d}</tt> is the function <tt>f</tt> defined by <tt>f(a)=1, f(b)=1010, f(c)=01, f(d)=10101</tt>. </p> <p> Any binary code can be naturally extended to encode strings over the alphabet <tt>S</tt> simply by concatenating the codes of the string's letters, in order. For example, using the code mentioned above we can encode <tt>cac</tt> as <tt>f(cac)=01101</tt>. </p> <p> A code is called <i>ambiguous</i> if there are two different strings over <tt>S</tt> that have the same encoding. Obviously, in practice we want to avoid using an ambiguous code. </p> <p> A code is called <i>really ambiguous</i> if there are <i>three</i> different strings over <tt>S</tt> that have the same encoding. For example, the code from the above example is really ambiguous: the strings <tt>ba</tt>, <tt>acc</tt>, and <tt>d</tt> are all encoded to <tt>10101</tt>. </p> <p> You will be given a String[] <b>code</b> containing the strings over <tt>{0,1}</tt> used to encode letters of some alphabet <tt>S</tt>. Your method should check whether this code is <i>really ambiguous</i>. If it is really ambiguous, find a shortest string over <tt>{0,1}</tt> that is an encoding of (at least) three different strings over <tt>S</tt>, and return its length. If the given code is not really ambiguous, return -1. </p></td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Definition</h3></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>Class:</td>
         <td>BinaryCodes</td>
        </tr>
        <tr>
         <td>Method:</td>
         <td>ambiguous</td>
        </tr>
        <tr>
         <td>Parameters:</td>
         <td>String[]</td>
        </tr>
        <tr>
         <td>Returns:</td>
         <td>int</td>
        </tr>
        <tr>
         <td>Method signature:</td>
         <td>int ambiguous(String[] code)</td>
        </tr>
        <tr>
         <td colspan="2">(be sure your method is public)</td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
    </tr>
    <tr>
     <td></td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Notes</h3></td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>Your method does not need to know the actual elements of <tt>S</tt>, and the size of <tt>S</tt> is obviously equal to the number of elements in <b>code</b>.</td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Constraints</h3></td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td><b>code</b> will contain between 2 and 30 elements, inclusive.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>Each element of <b>code</b> will contain between 0 and 50 characters, inclusive.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>Each element of <b>code</b> will only contain the characters '<tt>0</tt>' (zero) and '<tt>1</tt>' (one).</td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Examples</h3></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">0)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{&quot;1&quot;,&quot;1010&quot;,&quot;01&quot;,&quot;10101&quot;}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: 5</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This is the example from the problem statement, and the string <tt>10101</tt> is the shortest string that can be decoded in three different ways.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">1)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{&quot;0&quot;,&quot;1&quot;}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: -1</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This code is obviously not ambiguous. </td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">2)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{&quot;0&quot;,&quot;11&quot;,&quot;11&quot;,&quot;11&quot;}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: 2</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This is clearly a really ambiguous code, as there are three different one letter strings over <tt>S</tt> that are encoded to <tt>11</tt>. </td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">3)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{&quot;0000&quot;,&quot;001&quot;,&quot;01001&quot;,&quot;01010&quot;,&quot;01011&quot;}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: -1</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This code is a prefix code, i.e., no code word is a prefix of another code word. If a code has this property, it is guaranteed that it is not ambiguous, but the other direction is not true. </td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">4)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{&quot;1&quot;,&quot;10&quot;,&quot;00&quot;}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: -1</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This is not a prefix code, but it can easily be shown that this code is not ambiguous. </td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">5)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{&quot;&quot;,&quot;01101001001&quot;,&quot;111101011&quot;}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: 0</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">Having an empty code word is a great way how to design a really ambiguous code. </td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">6)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{&quot;00011011&quot;,&quot;000110&quot;,&quot;11&quot;,&quot;0001&quot;,&quot;1011&quot;,&quot;00&quot;,&quot;011011&quot;}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: 8</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">The shortest proof that this code is really ambiguous is <tt>00011011</tt>. Note that this string can in fact be decoded in four different ways.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
   </tbody>
  </table>
 </body>
</html>