<html>
 <head>
  <title>NormalizingTrees Problem Statement</title>
 </head>
 <body>
  <table>
   <tbody>
    <tr>
     <td colspan="2"><h3><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=7751">Problem Statement for NormalizingTrees</a></h3></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td><p> Trees are important data structures in programming. In this problem, you will be given a tree that was constructed from a fully connected undirected acyclic graph with exactly N nodes. First, a distinct number between 0 and N-1, inclusive, was assigned to each node. Then, one of the nodes was selected to be the root of the tree. Finally, each non-root node was assigned its neighbor closest to the root as its parent. </p><p> You will be given the <b>tree</b> as a int[], where the i-th element is the parent of the i-th node, or -1 if the i-th node is the root (indices are 0-based). A tree is considered equivalent to this tree if it can be constructed from the same original graph using the method described above. This means you can renumber the nodes and select a different node as the root (see examples for clarification). Return a int[] containing the equivalent tree that comes first lexicographically. A int[] <i>a<sub>1</sub></i> comes before int[] <i>a<sub>2</sub></i> lexicographically if <i>a<sub>1</sub></i> has a smaller value at the first element where they differ. </p></td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Definition</h3></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>Class:</td>
         <td>NormalizingTrees</td>
        </tr>
        <tr>
         <td>Method:</td>
         <td>normalize</td>
        </tr>
        <tr>
         <td>Parameters:</td>
         <td>int[]</td>
        </tr>
        <tr>
         <td>Returns:</td>
         <td>int[]</td>
        </tr>
        <tr>
         <td>Method signature:</td>
         <td>int[] normalize(int[] tree)</td>
        </tr>
        <tr>
         <td colspan="2">(be sure your method is public)</td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
    </tr>
    <tr>
     <td></td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Constraints</h3></td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td><b>tree</b> will contain between 1 and 50 elements, inclusive.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>Each element of <b>tree</b> will be between -1 and N-1, inclusive, where N is the number of elements in <b>tree</b>.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>Exactly one element of <b>tree</b> will be -1.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td><b>tree</b> will represent a connected acyclic graph.</td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Examples</h3></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">0)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{2,0,-1,4,2,4}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: {-1, 0, 0, 0, 1, 4 }</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This is the original drawing (with 2 as the root): <pre>
    2
   / \
  0   4
 /   / \
1   3   5
</pre> The renumbering gives this: <pre>
    1
   / \
  4   0
 /   / \
5   2   3
</pre> and taking the new 0 as the root gives the answer: <pre>
   0
 / | \
1  2  3
|
4
|
5
</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">1)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{-1,0,1,2,3}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: {-1, 0, 0, 1, 2 }</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This is a simple path of length 5. Selecting the middle node as root and renumbering gives the lexicographically first representation.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">2)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{3,3,3,4,-1,3}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: {-1, 0, 0, 0, 0, 0 }</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This tree has the shape of a star (one center node with 5 nodes connected to it).</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">3)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{10,9,6,10,6,9,7,-1,9,7,7,10,6}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: {-1, 0, 0, 0, 0, 1, 1, 5, 5, 5, 6, 6, 6 }</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2"></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">4)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{-1, 0, 0, 0, 0, 1, 1, 5, 5, 5, 6, 6, 6}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: {-1, 0, 0, 0, 0, 1, 1, 5, 5, 5, 6, 6, 6 }</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2"></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
   </tbody>
  </table>
 </body>
</html>