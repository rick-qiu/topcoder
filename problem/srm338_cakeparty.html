<html>
 <head>
  <title>CakeParty Problem Statement</title>
 </head>
 <body>
  <table>
   <tbody>
    <tr>
     <td colspan="2"><h3><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=7424">Problem Statement for CakeParty</a></h3></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td><p> Julianne invited her two friends Michael and Jane to a cake party. When Michael and Jane arrived, they saw that their host had prepared several tables. On each table there was a plate with one of the cakes. Each cake was cut into several pieces. </p> <p> Not knowing where to start, Michael and Jane decided to play the following game: Players take alternating turns. In each turn the player selects one cake, and takes and eats several pieces of the cake. The player must take and eat at least one piece. The player who eats the last piece of the last cake wins. </p> <p> However, the host would be really offended if she had the impression that the guests didn't like some of her cakes. Therefore Michael and Jane agreed on one additional rule: Each time a player selects a cake, he or she may only select one of those cakes that have the most pieces remaining. </p> <p> Michael starts the game and plays optimally. In other words, if there is a strategy that will ensure his win (no matter how Jane plays), he will follow one such strategy. If he finds himself in a position where no strategy can guarantee him winning the game he just makes a valid move. In addition, whenever Michael has more than one move to choose from, he picks the lexicographically smallest one (explained below). </p> <p> You are given a int[] <b>pieces</b>. The i-th element of <b>pieces</b> is the initial number of pieces of the i-th cake. Return Michael's first move as a String formatted as follows: &quot;<tt>CAKE C PIECES P</tt>&quot;, where <tt>C</tt> is the zero-based index of the cake he should select and <tt>P</tt> is the number of pieces he should eat. The numbers <tt>C</tt> and <tt>P</tt> must not contain unnecessary leading zeroes. In case there are multiple valid answers return the one where the resulting String is lexicographically smallest. </p> </td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Definition</h3></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>Class:</td>
         <td>CakeParty</td>
        </tr>
        <tr>
         <td>Method:</td>
         <td>makeMove</td>
        </tr>
        <tr>
         <td>Parameters:</td>
         <td>int[]</td>
        </tr>
        <tr>
         <td>Returns:</td>
         <td>String</td>
        </tr>
        <tr>
         <td>Method signature:</td>
         <td>String makeMove(int[] pieces)</td>
        </tr>
        <tr>
         <td colspan="2">(be sure your method is public)</td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
    </tr>
    <tr>
     <td></td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Notes</h3></td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>Ignore the appetite and eating speed of both players. In other words, assume that each of them is able to eat all the cakes in a short amount of time.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>When selecting the correct output, standard string comparison rules apply:<br /><br /> The string A is lexicograpically smaller than the string B if and only if (A is a proper prefix of B) or (there is an integer X such that first X-1 characters of A and B are equal, and the X-th character of A has a smaller ASCII value than the X-th character of B).</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>Valid characters ordered by their ASCII values (smallest to largest): space, digits '0'-'9' in this order, letters 'A'-'Z' in this order.</td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Constraints</h3></td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td><b>pieces</b> will contain between 1 and 50 elements, inclusive.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>Each element of <b>pieces</b> will be between 1 and 2,000,000,000, inclusive.</td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Examples</h3></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">0)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{47}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: &quot;CAKE 0 PIECES 47&quot;</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">With one cake the game is simple: just take everything.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">1)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{3,3}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: &quot;CAKE 0 PIECES 1&quot;</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">Two equally big cakes. This is clearly a losing position for the player to move. Thus we return the lexicographically smallest possible move.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">2)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{3,5}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: &quot;CAKE 1 PIECES 2&quot;</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">The winning move is to create the position from the previous example.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">3)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{1,1,1,1,1,1,1,1,1,1,1,1,1,1}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: &quot;CAKE 0 PIECES 1&quot;</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This is an almost deterministic game. The players can not influence the result at all.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">4)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{3,3,112}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: &quot;CAKE 2 PIECES 110&quot;</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">This is a winning position, as we can eat the entire last cake and thus create the position from Example 1. However, this is not the only winning move, and there is a lexicographically smaller winning move than the one we described.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">5)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{3,3,1}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: &quot;CAKE 0 PIECES 1&quot;</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">Note that we can not eat the last cake now, as it is not one of the largest ones.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">6)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>{4,7,4,7,4,7,4,7,47,47,47,47}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: &quot;CAKE 10 PIECES 1&quot;</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2"></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
   </tbody>
  </table>
 </body>
</html>