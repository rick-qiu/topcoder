<html>
 <head>
  <title>DiskScheduler Problem Statement</title>
 </head>
 <body>
  <table>
   <tbody>
    <tr>
     <td colspan="2"><h3><a href="http://community.topcoder.com/stat?c=problem_statement&amp;pm=2387">Problem Statement for DiskScheduler</a></h3></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td><p>Disk Scheduling is an important component of an operating system. The disk (or hard-drive) is composed of a number of cylinders. Each cylinder contains circular tracks, which in turn are divided into sectors. To read a particular sector the operating system must determine the cylinder and track it belongs to. It then rotates the cylinder so that the disk head is positioned at the desired sector. If the file being used is located on numerous sectors, scattered across the track, the disk scheduler must read all those sectors in such a way that minimizes total head movement.</p> <p>In practice it is impossible to implement an optimal disk scheduling algorithm, because requests to read sectors arrive one after another, instead of being known from the start. However, in our problem the order that the sectors are read can be changed to suit the fastest retrieval. The results of a theoretical optimal algorithm are useful when comparing the effectiveness of various real-life scheduling algorithms. </p> <p>For the purpose of this problem assume that a track has 100 sectors numbered from 1 to 100 inclusive. The cylinder can be rotated either clockwise or counter-clockwise. The cylinder is circular meaning that sector 1 is adjacent to sector 100. Given the <b>start</b> location of the head determine the minimal head movement required to read all the int[] <b>sectors</b>.</p> </td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Definition</h3></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>Class:</td>
         <td>DiskScheduler</td>
        </tr>
        <tr>
         <td>Method:</td>
         <td>optimize</td>
        </tr>
        <tr>
         <td>Parameters:</td>
         <td>int, int[]</td>
        </tr>
        <tr>
         <td>Returns:</td>
         <td>int</td>
        </tr>
        <tr>
         <td>Method signature:</td>
         <td>int optimize(int start, int[] sectors)</td>
        </tr>
        <tr>
         <td colspan="2">(be sure your method is public)</td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
    </tr>
    <tr>
     <td></td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Constraints</h3></td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td><b>start</b> will be between 1 and 100 inclusive.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td><b>sectors</b> will contain between 1 and 50 elements inclusive.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td>each element in <b>sectors</b> will be between 1 and 100 inclusive.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td><b>sectors</b> will not have any repeated elements.</td>
    </tr>
    <tr>
     <td align="center" valign="top">-</td>
     <td><b>start</b> will never be an element of <b>sectors</b>.</td>
    </tr>
    <tr>
     <td colspan="2">&nbsp;</td>
    </tr>
    <tr>
     <td colspan="2"><h3>Examples</h3></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">0)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>5</pre></td>
            </tr>
            <tr>
             <td><pre>{6,8,65,71}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: 46</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">The path 5-&gt;6-&gt;8-&gt;71-&gt;65 gives us the least head movement. In other words, rotate forward from 5 to 8, moving the head 3 sectors. Then rotate from 8 backwards to 71 for a total of (8-1) + (100-71) + 1 = 37. Finally rotate from 71 to 65, for a total of 3 + 37 + 16 = 46.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">1)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>5</pre></td>
            </tr>
            <tr>
             <td><pre>{55,65,71}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: 50</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">If we do 5-&gt;55-&gt;65-&gt;71 then we require 66 head movements. However if we go in the opposite direction 5-&gt;71-&gt;65-&gt;55 we only require 50 head movements, which is more efficient. Note that going from 5 to 71 requires only 5 + 29 = 34 head movements.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">2)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>20</pre></td>
            </tr>
            <tr>
             <td><pre>{1,21,99}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: 23</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">If we go 20-&gt;1-&gt;99-&gt;21 that will take 99 head movements. If we go 20-&gt;21-&gt;99-&gt;1 that will take 81 head movements. Finally, if we go 20-&gt;21-&gt;1-&gt;99 that will only take 23 head movements.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
    <tr>
     <td align="center" nowrap="true">3)</td>
     <td></td>
    </tr>
    <tr>
     <td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
     <td>
      <table>
       <tbody>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td><pre>99</pre></td>
            </tr>
            <tr>
             <td><pre>{55,56,61,70,76,78,80,83,84,90,1,4,6,26,27,33,38,46,47,49}</pre></td>
            </tr>
           </tbody>
          </table></td>
        </tr>
        <tr>
         <td><pre>Returns: 87</pre></td>
        </tr>
        <tr>
         <td>
          <table>
           <tbody>
            <tr>
             <td colspan="2">The sorted array is {1,4,6,26,27,33,38,46,47,49,55,56,61,70,76,78,80,83,84,90}. The most efficient way is to go right until we reach 6 and then go in the reverse direction until we reach 26.</td>
            </tr>
           </tbody>
          </table></td>
        </tr>
       </tbody>
      </table></td>
    </tr>
   </tbody>
  </table>
 </body>
</html>